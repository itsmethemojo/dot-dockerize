# use task name grouping
# improve when to clone when to copy stuff
# remove any expensive container usage from vars initialization
# move run.sh into taskfile
# use buildpack:: grouping for public targets
# determine latest version when needed in init task

# group directory_vars in DIRECTORY_

# task name switch entfernen
# auf testmodus prÃ¼fen und kopieren und dann exit 0, dann version bestimmen wenn die noch nicht da ist, danach den clone machen





version: '2'

expansions: 5

vars:
  BUILDPACK_REPOSITORY: 'https://github.com/itsmethemojo/buildpack.git'
  BUILDPACK_FOLDER: buildpack
  BUILDPACK_TMP_FOLDER: "{{.BUILDPACK_FOLDER}}/tmp"
  CONFIG_FOLDER: "{{.BUILDPACK_FOLDER}}/config"
  BASH_SCRIPT_TEMPLATE: "{{.BUILDPACK_TMP_FOLDER}}/bash/templates/run-task.sh"
  TASK_TARGET_TEMPLATE: "{{.BUILDPACK_TMP_FOLDER}}/taskfiles/templates/target-to-run-task.yml"
  SCRIPTS_FOLDER: "{{.BUILDPACK_FOLDER}}/scripts"
  TEST_MODE:
    sh: >-
      if [ -f "../tests.bats" ]; then
      echo 1;
      else
      echo 0;
      fi;
  BUILDPACK_VERSION:
    sh: >-
      BUILDPACK_VERSION=$VERSION;
      if [ "$BUILDPACK_VERSION" == "" ]; then
        BUILDPACK_VERSION="$(grep -e "^#BUILDPACK_VERSION:" Taskfile.yml 2>/dev/null | grep -o -e '[^:]*$')";
      fi;
      if [ "$BUILDPACK_VERSION" == "" ] && [ ! -f "../tests.bats" ]; then
        BUILDPACK_VERSION=$(git ls-remote -t git@github.com:itsmethemojo/buildpack.git | awk '{print $2}' | cut -d '/' -f 3 | cut -d '^' -f 1 | tail -1);
      fi;
      echo $BUILDPACK_VERSION;
  ABSOLUTE_PROJECT_ROOT:
    sh: "pwd"
  PROJECT_FOLDER_NAME:
    sh: "echo ${PWD##*/}"
  TASK_SCRIPT_PATH: "{{.SCRIPTS_FOLDER}}/$name.sh"
  TASK_CONFIG_FILE: "{{.CONFIG_FOLDER}}/tasks.env"
  TASK_DEFAULT_CONTAINER: "buildpack-deps"
  TASK_DIR_IN_CONTAINER: "/container-$name"
  TASK_CONTAINER_MOUNT_PARAMETERS: "-v $(pwd):{{.TASK_DIR_IN_CONTAINER}}"
  TASK_CONTAINER_NAME:
    sh: >-
      CONFIG_FILE=buildpack/config/tasks.env
      RETURN_CONTAINER_NAME=buildpack-deps;
      if [ "$(grep -e "^${name}_container=" $CONFIG_FILE 2>/dev/null | grep -o -e '[^=]*$')" != "" ]; then
        RETURN_CONTAINER_NAME="$(grep -e "^${name}_container=" $CONFIG_FILE 2>/dev/null | grep -o -e '[^=]*$')";
      fi;
      if [ "$(grep -e "^${name}_dockerfile=" $CONFIG_FILE 2>/dev/null | grep -o -e '[^=]*$')" != "" ]; then
        RETURN_CONTAINER_NAME="buildpack-{{.PROJECT_FOLDER_NAME}}-task-${name}";
      fi;
      echo $RETURN_CONTAINER_NAME;
  TASK_DOCKERFILE_PATH:
    sh: >-
      echo "$(grep -e "^${name}_dockerfile=" buildpack/config/tasks.env 2>/dev/null | grep -o -e '[^=]*$')";
  TESTS_OUTPUT_FILE:
    sh: echo tests/output-$(date +%s).log;

tasks:

  add:
    desc: name=new-task-name task add                       adds a new task that can be later used with task new-task-name
    deps: [ _check_init_needed ]
    cmds:
      - task: _create_task_script
      - task: _update:taskfile
      - task: _print_version

  buildpack_test:
    desc: '[VERSION=version] task buildpack_test             runs tests for builpack framework, optional parameter to select a specific version to test'
    cmds:
      - cmd: ./tests/run.sh | tee {{.TESTS_OUTPUT_FILE}};
        ignore_error: true
        silent: false

  init:
    desc: '[VERSION=version] task init                       setup initial config and downloads needed dependencies, optional parameter to select a specific version'
    cmds:
      - task: _init:download
      - task: _init:create_config_files
      - task: _init:update_gitignore
      - task: _update:taskfile
      - task: _print_version

  upgrade:
    desc: task upgrade                                      will upgrade your buildpack version to the most current available
    cmds:
      - cmd: >-
          NEWEST_VERSION=$(git ls-remote -t git@github.com:itsmethemojo/buildpack.git | awk '{print $2}' | cut -d '/' -f 3 | cut -d '^' -f 1 | tail -1);
          if [ "$NEWEST_VERSION" == "{{.BUILDPACK_VERSION}}" ]; then
            echo 'buildpack is already on the newest version';
          else
            VERSION=$NEWEST_VERSION task init
          fi
        silent: false

  version:
    desc: task version                                     prints the current used version of task
    deps: [ _check_init_needed ]
    cmds:
      - task: _print_version

  # private targets

  _check_init_needed:
    cmds:
      - cmd: >-
          if [ ! -f "{{.BASH_SCRIPT_TEMPLATE}}" ]; then
            echo 'Important files missing. Buildpack seems not be installed. Run "task init" to fix that.';
            exit 1;
          fi
        silent: false

  _init:create_config_files:
    cmds:
      - cmd: >-
          mkdir -p {{.CONFIG_FOLDER}}/docker;
          touch {{.CONFIG_FOLDER}}/tasks.env
        silent: false

  _create_task_script:
    deps: [ _has_name_parameter ]
    cmds:
      - cmd: >-
          mkdir -p {{.SCRIPTS_FOLDER}};
          touch {{.SCRIPTS_FOLDER}}/{{.name}}.sh;
          chmod +x {{.SCRIPTS_FOLDER}}/{{.name}}.sh;
          cat {{.BASH_SCRIPT_TEMPLATE}} >> {{.SCRIPTS_FOLDER}}/{{.name}}.sh
        silent: false

  _init:download:
    cmds:
      - cmd: >-
          rm -rf {{.ABSOLUTE_PROJECT_ROOT}}/{{.BUILDPACK_TMP_FOLDER}};
          mkdir -p {{.ABSOLUTE_PROJECT_ROOT}}/{{.BUILDPACK_TMP_FOLDER}};
          if [ {{.TEST_MODE}} -eq 1 ] && [ "{{.BUILDPACK_VERSION}}" == "" ];
          then
          cp -R {{.ABSOLUTE_PROJECT_ROOT}}/../../taskfiles {{.ABSOLUTE_PROJECT_ROOT}}/{{.BUILDPACK_TMP_FOLDER}}/;
          cp -R {{.ABSOLUTE_PROJECT_ROOT}}/../../bash {{.ABSOLUTE_PROJECT_ROOT}}/{{.BUILDPACK_TMP_FOLDER}}/;
          cp {{.ABSOLUTE_PROJECT_ROOT}}/../../Taskfile.yml {{.ABSOLUTE_PROJECT_ROOT}}/{{.BUILDPACK_TMP_FOLDER}}/Taskfile.yml;
          else
          docker run -v {{.ABSOLUTE_PROJECT_ROOT}}/{{.BUILDPACK_TMP_FOLDER}}:/downloads buildpack-deps
          bash -c "
          git clone -b {{.BUILDPACK_VERSION}} --depth 1 {{.BUILDPACK_REPOSITORY}} /downloads &> /dev/null &&
          rm -r /downloads/.git &&
          chmod -R 777 /downloads
          ";
          fi;
        silent: false

  _has_name_parameter:
    cmds:
      - cmd: >-
          if [ "$name" == "" ]; then
            echo 'missing Parameter name! Usage: name="my-task" task add';
            exit 1;
          fi
        silent: false

  _print_version:
    cmds:
      - cmd: >-
          echo Buildpack Version: {{.BUILDPACK_VERSION}};
        silent: false

  _run:
    deps: [ _check_init_needed ]
    cmds:
      - task: _script:start_watch
      - task: _print_version
      - task: _script:run
      - task: _script:stop_watch

  _script:run:
    cmds:
      - cmd: >-
          if [ "{{.TASK_DOCKERFILE_PATH}}" != "" ]; then
            docker build -t {{.TASK_CONTAINER_NAME}} -f "{{.TASK_DOCKERFILE_PATH}}" $(dirname "{{.TASK_DOCKERFILE_PATH}}");
          fi;
          if [ -f "/.dockerenv" ]; then
            bash {{.TASK_DIR_IN_CONTAINER}}/{{.TASK_SCRIPT_PATH}};
          else
            docker run {{.TASK_CONTAINER_MOUNT_PARAMETERS}} -w {{.TASK_DIR_IN_CONTAINER}} {{.TASK_CONTAINER_NAME}} bash {{.TASK_SCRIPT_PATH}};
          fi;
        silent: false

  _script:start_watch:
    cmds:
      - cmd: >-
          echo $(date +%s) > {{.BUILDPACK_TMP_FOLDER}}/start-watch-$name
        silent: false

  _script:stop_watch:
    cmds:
      - cmd: >-
          echo -e "\nDuration: $(( $(date +%s) - $( cat {{.BUILDPACK_TMP_FOLDER}}/start-watch-$name ) ))s" &&
          rm {{.BUILDPACK_TMP_FOLDER}}/start-watch-$name
        silent: false

  _init:update_gitignore:
    cmds:
      - cmd: >-
          if [ ! -f .gitignore ]; then
            echo "/{{.BUILDPACK_TMP_FOLDER}}"/ > .gitignore;
          fi;
          if [ "$(grep "/{{.BUILDPACK_TMP_FOLDER}}/" .gitignore | wc -l)" = "0" ]; then
            echo "/{{.BUILDPACK_TMP_FOLDER}}/" >> .gitignore;
          fi
        silent: false

  _update:taskfile:
    cmds:
      - cmd: >-
          echo -e "#BUILDPACK_VERSION: {{.BUILDPACK_VERSION}}\n" > Taskfile.yml &&
          cat {{.BUILDPACK_TMP_FOLDER}}/Taskfile.yml >> Taskfile.yml
        silent: false
      - cmd: >-
          for SCRIPT_FILE in $(ls -1 {{.SCRIPTS_FOLDER}} 2>/dev/null | sed -e 's/\..*$//'); do
          cat {{.TASK_TARGET_TEMPLATE}} | sed "s/__TASKNAME__/$SCRIPT_FILE/g" >> Taskfile.yml;
          done
        silent: false
